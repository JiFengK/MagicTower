//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1026
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

public class TileMapManager : Singleton<TileMapManager>
{
	private Dictionary<uint, TileMap> mMaps;

	public TileMap GetMap(uint lv)
	{
		TileMap map = null;
		if (mMaps.TryGetValue (lv, out map))
			return map;

		return null;
	}

	public bool HasLoaded(uint lv)
	{
		TileMap map = null;
		if (mMaps.TryGetValue (lv, out map))
			return true;
		
		return false;
	}

	public TileMapManager ()
	{
		mMaps = new Dictionary<uint, TileMap> ();
	}

	private GameObject mTileMapObj;
	public GameObject TileMapObj
	{
		get { return mTileMapObj; }
		set { mTileMapObj = value; }
	}

	private GameObject mPlayerObj;
	public GameObject PlayerObj
	{
		get { return mPlayerObj; }
		set { mPlayerObj = value; }
	}

	private int parseMapSize(string[] content, int cur, out uint width, out uint height)
	{
		++cur;

		var tmp = content[cur++].Split (new char[] {','});
		width = Convert.ToUInt32 (tmp [0]);
		height = Convert.ToUInt32 (tmp [1]);

		return cur;
	}

	private int parseLayer(string[] content, int cur, TileMap.TileLayer layer)
	{
		++cur;

		var width = layer.Width;
		var height = layer.Height;

		for (int r = 0; r < height; ++r, ++cur) {
			for (int c = 0; c < width; ++c) {
				var tile_char = content[cur][c];
				var tile = TileFactory.Instance.CreateTile(tile_char);
				if (tile != null) {
					layer[height - r - 1, c] = tile;
				}
			}
		}

		return cur;
	}

	private int parseMonter(string[] content, int cur, TileMap.TileLayer layer)
	{
		++cur;

		int count = Convert.ToInt32 (content [cur++]);
		for (int i = 0; i < count; ++i, ++cur) {
			// TODO add monster
		}

		return cur;
	}

	private int parseNpc(string[] content, int cur, TileMap.TileLayer layer)
	{
		++cur;
		
		int count = Convert.ToInt32 (content [cur++]);
		for (int i = 0; i < count; ++i, ++cur) {
			// TODO add npc
		}
		
		return cur;
	}

	private int parseItem(string[] content, int cur, TileMap.TileLayer layer)
	{
		++cur;
		
		int count = Convert.ToInt32 (content [cur++]);
		for (int i = 0; i < count; ++i, ++cur) {
			// TODO add item
		}
		
		return cur;
	}

	private int parsePortal(string[] content, int cur, TileMap.TileLayer layer)
	{
		++cur;
		
		int count = Convert.ToInt32 (content [cur++]);
		for (int i = 0; i < count; ++i, ++cur) {

		}
		
		return cur;
	}

	public TileMap LoadMap(uint lv)
	{
		var asset = Resources.Load ("level" + lv) as TextAsset;
		var content = asset.text.Split (new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries);

		int cur_idx = 0;

		// map size
		uint width, height;
		cur_idx = parseMapSize (content, cur_idx, out width, out height);
	
		var map = mTileMapObj.AddComponent<TileMap>();
		map.Init (width, height);

		// layer 0
		cur_idx = parseLayer (content, cur_idx, map.LayerFloor);

		// layer 1
		cur_idx = parseLayer (content, cur_idx, map.LayerCollide);

		// monster
		cur_idx = parseMonter (content, cur_idx, map.LayerCollide);

		// npc
		cur_idx = parseMonter (content, cur_idx, map.LayerCollide);

		// item
		cur_idx = parseMonter (content, cur_idx, map.LayerCollide);

		// portal
		cur_idx = parsePortal (content, cur_idx, map.LayerCollide);

		return map;
	}

	public TileMap EnterMap(uint lv, uint x, uint y)
	{
		var map = GetMap (lv);
		if (map == null)
			map = LoadMap (lv);

		// TODO place actor to x, y
		return map;
	}
}

